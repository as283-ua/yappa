// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"
)

const addMessage = `-- name: AddMessage :exec
INSERT INTO chat_inbox_messages (inbox_code, serial_n, enc_msg) 
VALUES ($1, $2, $3)
`

type AddMessageParams struct {
	InboxCode []byte
	SerialN   int64
	EncMsg    []byte
}

// -- CHAT MESSAGES
func (q *Queries) AddMessage(ctx context.Context, arg AddMessageParams) error {
	_, err := q.db.Exec(ctx, addMessage, arg.InboxCode, arg.SerialN, arg.EncMsg)
	return err
}

const createInbox = `-- name: CreateInbox :exec
INSERT INTO chat_inboxes (code, current_token_hash, enc_token, key_exchange_data) 
VALUES ($1, NULL, NULL, NULL)
`

// -- CHAT INBOXES
func (q *Queries) CreateInbox(ctx context.Context, code []byte) error {
	_, err := q.db.Exec(ctx, createInbox, code)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (username, certificate, pub_key_exchange) 
VALUES ($1, $2, $3)
`

type CreateUserParams struct {
	Username       string
	Certificate    string
	PubKeyExchange []byte
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser, arg.Username, arg.Certificate, arg.PubKeyExchange)
	return err
}

const deleteNewUserInboxes = `-- name: DeleteNewUserInboxes :exec
DELETE FROM user_inboxes
WHERE username = $1
`

func (q *Queries) DeleteNewUserInboxes(ctx context.Context, username string) error {
	_, err := q.db.Exec(ctx, deleteNewUserInboxes, username)
	return err
}

const flushInbox = `-- name: FlushInbox :exec
DELETE FROM chat_inbox_messages
WHERE inbox_code = $1
`

func (q *Queries) FlushInbox(ctx context.Context, inboxCode []byte) error {
	_, err := q.db.Exec(ctx, flushInbox, inboxCode)
	return err
}

const getInboxToken = `-- name: GetInboxToken :one
SELECT current_token_hash, enc_token, key_exchange_data
FROM chat_inboxes
WHERE code = $1
`

type GetInboxTokenRow struct {
	CurrentTokenHash []byte
	EncToken         []byte
	KeyExchangeData  []byte
}

func (q *Queries) GetInboxToken(ctx context.Context, code []byte) (GetInboxTokenRow, error) {
	row := q.db.QueryRow(ctx, getInboxToken, code)
	var i GetInboxTokenRow
	err := row.Scan(&i.CurrentTokenHash, &i.EncToken, &i.KeyExchangeData)
	return i, err
}

const getMessages = `-- name: GetMessages :many
SELECT enc_msg, serial_n
FROM chat_inbox_messages
WHERE inbox_code = $1
`

type GetMessagesRow struct {
	EncMsg  []byte
	SerialN int64
}

func (q *Queries) GetMessages(ctx context.Context, inboxCode []byte) ([]GetMessagesRow, error) {
	rows, err := q.db.Query(ctx, getMessages, inboxCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesRow
	for rows.Next() {
		var i GetMessagesRow
		if err := rows.Scan(&i.EncMsg, &i.SerialN); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewUserInboxes = `-- name: GetNewUserInboxes :many
SELECT enc_sender, enc_inbox_code, enc_serial, enc_signature, key_exchange_data
FROM user_inboxes
WHERE username = $1
`

type GetNewUserInboxesRow struct {
	EncSender       []byte
	EncInboxCode    []byte
	EncSerial       []byte
	EncSignature    []byte
	KeyExchangeData []byte
}

func (q *Queries) GetNewUserInboxes(ctx context.Context, username string) ([]GetNewUserInboxesRow, error) {
	rows, err := q.db.Query(ctx, getNewUserInboxes, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNewUserInboxesRow
	for rows.Next() {
		var i GetNewUserInboxesRow
		if err := rows.Scan(
			&i.EncSender,
			&i.EncInboxCode,
			&i.EncSerial,
			&i.EncSignature,
			&i.KeyExchangeData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserData = `-- name: GetUserData :one
SELECT id, username, certificate, pub_key_exchange
FROM users
WHERE username = $1
`

// -- USER + AUTH
func (q *Queries) GetUserData(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserData, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Certificate,
		&i.PubKeyExchange,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT username
FROM users
WHERE username ILIKE $3
LIMIT $1 OFFSET $2
`

type GetUsersParams struct {
	Limit    int32
	Offset   int32
	Username string
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getUsers, arg.Limit, arg.Offset, arg.Username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var username string
		if err := rows.Scan(&username); err != nil {
			return nil, err
		}
		items = append(items, username)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newUserInbox = `-- name: NewUserInbox :exec
INSERT INTO user_inboxes (username, enc_sender, enc_signature, enc_serial, enc_inbox_code, key_exchange_data)
VALUES ($1, $2, $3, $4, $5, $6)
`

type NewUserInboxParams struct {
	Username        string
	EncSender       []byte
	EncSignature    []byte
	EncSerial       []byte
	EncInboxCode    []byte
	KeyExchangeData []byte
}

// -- USER PERSONAL INBOXES
func (q *Queries) NewUserInbox(ctx context.Context, arg NewUserInboxParams) error {
	_, err := q.db.Exec(ctx, newUserInbox,
		arg.Username,
		arg.EncSender,
		arg.EncSignature,
		arg.EncSerial,
		arg.EncInboxCode,
		arg.KeyExchangeData,
	)
	return err
}

const setToken = `-- name: SetToken :exec
UPDATE chat_inboxes
SET current_token_hash = $2, enc_token = $3, key_exchange_data = $4
WHERE code = $1
`

type SetTokenParams struct {
	Code             []byte
	CurrentTokenHash []byte
	EncToken         []byte
	KeyExchangeData  []byte
}

func (q *Queries) SetToken(ctx context.Context, arg SetTokenParams) error {
	_, err := q.db.Exec(ctx, setToken,
		arg.Code,
		arg.CurrentTokenHash,
		arg.EncToken,
		arg.KeyExchangeData,
	)
	return err
}
